# 引用计数

python通过对一个对象的引用计数的管理来维护对象在内存中的存在与否。python的每一个东西都是一个对象，都有一个ob_refcnt变量。这个变量维护这该对象的引用计数，从而也最终决定着该对象的创建与消亡。

在python中，主要是通过Py_INCREF(op)和Py_DECREF(op)两个宏来增加和减少一个对象的引用计数。当一个对象的引用计数减少至0之后，Py_DECREF将调用该对象的西沟函数来释放该对象所占有的内存和系统资源。这里的析构函数借用了c++的词汇，实际上这个析构动作是通过对象对应的类型对象中定义的一个函数指针来指定的，就是那个tp_dealloc.

如果熟悉设计模式中的Observer模式，就可以看到，这里隐隐约约透着Observer模式的影子。在ob_refcnt减为0之后，将处罚对象销毁的事件。从Python的对象体系来看，各个对象提供了不同的事件处理函数，而事件的注册动作正是在各个对象对应的类型对象中静态完成的。

PyObject中的ob_refcnt是一个32位的整型变量，这实际蕴含着Python所做的一个假设，即对一个对象的的引用不会超过一个整型变量的最大值。一般情况下，如果不是恶意代码，这个假设显然成立。

需要注意的是，在Python各个对象中，类型对象是超越引用计数规则的。类型对象“跳出三界外，不再五行中”，永远不会被析构。每一个对象中指向类型对象的指针不被视为对类型对象的引用。

在每一个对象创建的时候，Python提供了一个_Py_NewRefrerence(op)宏来将对象的引用计数初始化为1.

在Python的源代码中可以看到，在不同的编译选项下（Py_REF_DEBUG,Py_TRACE_REFS)，引用计数的宏还要做许多额外的工作。

在一个对象的引用计数减为0时，与该对象对应的析构函数就会被调用，但是要特别注意的是，调用析构函数并不意味着最终一定会调用free释放内存空间，如果真是这样的话，那频繁的申请，释放内存空间会使Python的执行效率大打折扣。一般来说，Python中大量采用了内存对象池的技术，使用这种技术可以避免频繁的申请和释放内存空间。因此在析构时，通常是将对象占用的空间归还给内存池中。