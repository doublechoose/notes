C# 1 所搭建的核心基础



委托 delegate

简单委托的构成

- 声明委托类型
- 必须有一个方法包含了要执行的代码
- 必须创建一个委托实例
- 必须调用委托实例



委托总结

- 委托封装了包含特殊返回类型和一组参数的行为，类似包含单一方法的接口；
- 委托类型声明中所描述的类型的签名决定了那个方法可以用于创建委托实例，同时决定了调用的签名；
- 为了创建委托实例，需要一个方法以及（对于实例方法来说）调用方法的目标；
- 委托实例是不易变的；
- 每个委托实例都包含一个调用列表---- 一个操作列表；
- 委托实例可以合并到一起，也可以从一个委托实例中删除另一个；
- 事件不是委托实例---- 只是成对的add/remove 方法（类似于属性的取值方法/赋值方法）。

C#1的类型系统是静态的、显式的和安全的。

C#是静态类型的：每个变量都有一个特定的类型，而且该类型在编译时是已知的。

静态这个词用来描述表达式的编译时类型，因为它们使用不变的（ unchanging）数据来分析哪些操作可用。 

无论隐式类型还是显式类型，变量的类型在编译时都是已知的——即使在代码中没有显式地声明。 在动态类型的情况下，变量根本没有一个类型可供声明或推断 。



C# 1的特征：
 C# 1是静态类型的——编译器知道你能使用哪些成员；
 C# 1是显式的——必须告诉编译器变量具有什么类型；
 C# 1是安全的——除非存在真实的转换关系，否则不能将一种类型当做另一种类型；
 静态类型仍然不允许一个集合成为强类型的“字符串列表”或者“整数列表”，除非针对不同的元素使用大量的重复代码；
 方法覆盖和接口实现不允许协变性/逆变性 



 对于引用类型的变量，它的值永远是一个引用；
 对于值类型的变量，它的值永远是该值类型的一个值。 



```c#
int i = 5;
object o = i;
int j = (int)o;
```



这里有两个变量： i是值类型的变量， o是引用类型的变量。将i的值赋给o有道理吗？ o的值必须是一个引用，而数字5不是引用，它是一个整数值。实际发生的事情就是装箱：运行时将在堆上创建一个包含值（ 5）的对象（它是一个普通对象）。 o的值是对该新对象的一个引用。该对象的值是原始值的一个副本，改变i的值不会改变箱内的值。 

第3行执行相反的操作——拆箱。必须告诉编译器将object拆箱成什么类型。如果使用了错误的类型（比如o原先被装箱成unit或者long，或者根本就不是一个已装箱的值），就会抛出一个InvalidCastException异常。同样，拆箱也会复制箱内的值，在赋值之后， j和该对象之间不再有任何关系 。

拆箱一般是很容易看出来，因为要在代码中明确地显示一个强制类型转换。
装箱则可能悄悄进行。 