

封装、继承、多态

## 封装

把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行隐藏。

## 继承

使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。

继承的过程就是从一般到特殊的过程。

要实现继承，可以通过“继承”和“组合”来实现

继承概念的实现方式有三类：实现继承、接口继承和可视继承。

两个类之间的关系应该是属于关系。

## 多态

允许将父对象设置成为和一个或更多他的子对象相等的技术，赋值之后，父对象就可以给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类型的指针赋值给父类类型的指针。

实现多态，有2种方式，覆盖，重载


java的重写,是指在子类中对父类的某方法进行重新定义,其子类的该方法名以及参数位置和个数均与父类相同,从而在调用子类的该方法时,不会执行父类的方法。如果在父类中以final定义的方法,在子类中无法重写。
Java的重载，就是在类中可以创建多个方法，它们具有相同的名字，但具有不同的参数和不同的定义。调用方法时通过传递给它们的不同参数个数和参数类型来决定具体使用哪个方法, 这就是多态性。
重写就是再写一遍，重载就是再多一个。重写：父类里有，子类再照猫画虎写一个。重载：自己类里面有，觉得不够再写一个。


覆盖，是指子类重新定义父类的虚函数的做法。

重载，是指允许多个同名函数，而这些函数的参数表不同（或者参数个数不同，或者参数类型不同，或者都不同）。

其实，重载的概念并不属于“面向对象编程”，重载的实现是：编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数（至少对于编译器来说是这样的）。如，有两个同名函数：function func(p:integer):integer;和function func(p:string):integer;。那么编译器做过修饰后的函数名称可能是这样的：int_func、str_func。对于这两个函数的调用，在编译器间就已经确定了，是静态的（记住：是静态）。也就是说，它们的地址在编译期就绑定了（早绑定），因此，重载和多态无关！真正和多态相关的是“覆盖”。当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态（记住：是动态！）的调用属于子类的该函数，这样的函数调用在编译期间是无法确定的（调用的子类的虚函数的地址无法给出）。因此，这样的函数地址是在运行期绑定的（晚邦定）。结论就是：重载只是一种语言特性，与多态无关，与面向对象也无关！引用一句Bruce Eckel的话：“不要犯傻，如果它不是晚绑定，它就不是多态。”

那么，多态的作用是什么呢？我们知道，封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）；它们的目的都是为了——代码重用。而多态则是为了实现另一个目的——接口重用！多态的作用，就是为了类在继承和派生的时候，保证使用“家谱”中任一类的实例的某一属性时的正确调用。

 
